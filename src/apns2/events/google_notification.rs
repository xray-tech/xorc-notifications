// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GoogleLocalizedAlert {
    // message fields
    title: ::protobuf::SingularField<::std::string::String>,
    body: ::protobuf::SingularField<::std::string::String>,
    icon: ::protobuf::SingularField<::std::string::String>,
    sound: ::protobuf::SingularField<::std::string::String>,
    badge: ::protobuf::SingularField<::std::string::String>,
    tag: ::protobuf::SingularField<::std::string::String>,
    color: ::protobuf::SingularField<::std::string::String>,
    click_action: ::protobuf::SingularField<::std::string::String>,
    body_loc_key: ::protobuf::SingularField<::std::string::String>,
    body_loc_args: ::protobuf::RepeatedField<::std::string::String>,
    title_loc_key: ::protobuf::SingularField<::std::string::String>,
    title_loc_args: ::protobuf::RepeatedField<::std::string::String>,
    data: ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GoogleLocalizedAlert {
    pub fn new() -> GoogleLocalizedAlert {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string icon = 3;

    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sound = 4;

    pub fn clear_sound(&mut self) {
        self.sound.clear();
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::std::string::String) {
        self.sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::std::string::String {
        if self.sound.is_none() {
            self.sound.set_default();
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::std::string::String {
        self.sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string badge = 5;

    pub fn clear_badge(&mut self) {
        self.badge.clear();
    }

    pub fn has_badge(&self) -> bool {
        self.badge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge(&mut self, v: ::std::string::String) {
        self.badge = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_badge(&mut self) -> &mut ::std::string::String {
        if self.badge.is_none() {
            self.badge.set_default();
        }
        self.badge.as_mut().unwrap()
    }

    // Take field
    pub fn take_badge(&mut self) -> ::std::string::String {
        self.badge.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_badge(&self) -> &str {
        match self.badge.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tag = 6;

    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag.set_default();
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string color = 7;

    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        if self.color.is_none() {
            self.color.set_default();
        }
        self.color.as_mut().unwrap()
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        self.color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string click_action = 8;

    pub fn clear_click_action(&mut self) {
        self.click_action.clear();
    }

    pub fn has_click_action(&self) -> bool {
        self.click_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_click_action(&mut self, v: ::std::string::String) {
        self.click_action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_click_action(&mut self) -> &mut ::std::string::String {
        if self.click_action.is_none() {
            self.click_action.set_default();
        }
        self.click_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_click_action(&mut self) -> ::std::string::String {
        self.click_action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_click_action(&self) -> &str {
        match self.click_action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string body_loc_key = 9;

    pub fn clear_body_loc_key(&mut self) {
        self.body_loc_key.clear();
    }

    pub fn has_body_loc_key(&self) -> bool {
        self.body_loc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_loc_key(&mut self, v: ::std::string::String) {
        self.body_loc_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_loc_key(&mut self) -> &mut ::std::string::String {
        if self.body_loc_key.is_none() {
            self.body_loc_key.set_default();
        }
        self.body_loc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_loc_key(&mut self) -> ::std::string::String {
        self.body_loc_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_body_loc_key(&self) -> &str {
        match self.body_loc_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string body_loc_args = 10;

    pub fn clear_body_loc_args(&mut self) {
        self.body_loc_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_loc_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_loc_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_loc_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_loc_args
    }

    // Take field
    pub fn take_body_loc_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_loc_args, ::protobuf::RepeatedField::new())
    }

    pub fn get_body_loc_args(&self) -> &[::std::string::String] {
        &self.body_loc_args
    }

    // optional string title_loc_key = 11;

    pub fn clear_title_loc_key(&mut self) {
        self.title_loc_key.clear();
    }

    pub fn has_title_loc_key(&self) -> bool {
        self.title_loc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title_loc_key(&mut self, v: ::std::string::String) {
        self.title_loc_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title_loc_key(&mut self) -> &mut ::std::string::String {
        if self.title_loc_key.is_none() {
            self.title_loc_key.set_default();
        }
        self.title_loc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_title_loc_key(&mut self) -> ::std::string::String {
        self.title_loc_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_title_loc_key(&self) -> &str {
        match self.title_loc_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string title_loc_args = 12;

    pub fn clear_title_loc_args(&mut self) {
        self.title_loc_args.clear();
    }

    // Param is passed by value, moved
    pub fn set_title_loc_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.title_loc_args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_title_loc_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.title_loc_args
    }

    // Take field
    pub fn take_title_loc_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.title_loc_args, ::protobuf::RepeatedField::new())
    }

    pub fn get_title_loc_args(&self) -> &[::std::string::String] {
        &self.title_loc_args
    }

    // repeated .common.MapFieldEntry data = 13;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[super::map_field_entry::MapFieldEntry] {
        &self.data
    }
}

impl ::protobuf::Message for GoogleLocalizedAlert {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sound)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.badge)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.click_action)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body_loc_key)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_loc_args)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title_loc_key)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.title_loc_args)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.sound.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.badge.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.click_action.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.body_loc_key.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.body_loc_args {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.title_loc_key.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.title_loc_args {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.sound.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.badge.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.click_action.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.body_loc_key.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.body_loc_args {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.title_loc_key.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.title_loc_args {
            os.write_string(12, &v)?;
        };
        for v in &self.data {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoogleLocalizedAlert {
        GoogleLocalizedAlert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &GoogleLocalizedAlert| { &m.title },
                    |m: &mut GoogleLocalizedAlert| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    |m: &GoogleLocalizedAlert| { &m.body },
                    |m: &mut GoogleLocalizedAlert| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "icon",
                    |m: &GoogleLocalizedAlert| { &m.icon },
                    |m: &mut GoogleLocalizedAlert| { &mut m.icon },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sound",
                    |m: &GoogleLocalizedAlert| { &m.sound },
                    |m: &mut GoogleLocalizedAlert| { &mut m.sound },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "badge",
                    |m: &GoogleLocalizedAlert| { &m.badge },
                    |m: &mut GoogleLocalizedAlert| { &mut m.badge },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tag",
                    |m: &GoogleLocalizedAlert| { &m.tag },
                    |m: &mut GoogleLocalizedAlert| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &GoogleLocalizedAlert| { &m.color },
                    |m: &mut GoogleLocalizedAlert| { &mut m.color },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "click_action",
                    |m: &GoogleLocalizedAlert| { &m.click_action },
                    |m: &mut GoogleLocalizedAlert| { &mut m.click_action },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body_loc_key",
                    |m: &GoogleLocalizedAlert| { &m.body_loc_key },
                    |m: &mut GoogleLocalizedAlert| { &mut m.body_loc_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body_loc_args",
                    |m: &GoogleLocalizedAlert| { &m.body_loc_args },
                    |m: &mut GoogleLocalizedAlert| { &mut m.body_loc_args },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title_loc_key",
                    |m: &GoogleLocalizedAlert| { &m.title_loc_key },
                    |m: &mut GoogleLocalizedAlert| { &mut m.title_loc_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title_loc_args",
                    |m: &GoogleLocalizedAlert| { &m.title_loc_args },
                    |m: &mut GoogleLocalizedAlert| { &mut m.title_loc_args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::map_field_entry::MapFieldEntry>>(
                    "data",
                    |m: &GoogleLocalizedAlert| { &m.data },
                    |m: &mut GoogleLocalizedAlert| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoogleLocalizedAlert>(
                    "GoogleLocalizedAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoogleLocalizedAlert {
        static mut instance: ::protobuf::lazy::Lazy<GoogleLocalizedAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoogleLocalizedAlert,
        };
        unsafe {
            instance.get(GoogleLocalizedAlert::new)
        }
    }
}

impl ::protobuf::Clear for GoogleLocalizedAlert {
    fn clear(&mut self) {
        self.clear_title();
        self.clear_body();
        self.clear_icon();
        self.clear_sound();
        self.clear_badge();
        self.clear_tag();
        self.clear_color();
        self.clear_click_action();
        self.clear_body_loc_key();
        self.clear_body_loc_args();
        self.clear_title_loc_key();
        self.clear_title_loc_args();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoogleLocalizedAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoogleLocalizedAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoogleMessage {
    // message fields
    data: ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GoogleMessage {
    pub fn new() -> GoogleMessage {
        ::std::default::Default::default()
    }

    // repeated .common.MapFieldEntry data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<super::map_field_entry::MapFieldEntry> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[super::map_field_entry::MapFieldEntry] {
        &self.data
    }
}

impl ::protobuf::Message for GoogleMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoogleMessage {
        GoogleMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::map_field_entry::MapFieldEntry>>(
                    "data",
                    |m: &GoogleMessage| { &m.data },
                    |m: &mut GoogleMessage| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoogleMessage>(
                    "GoogleMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoogleMessage {
        static mut instance: ::protobuf::lazy::Lazy<GoogleMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoogleMessage,
        };
        unsafe {
            instance.get(GoogleMessage::new)
        }
    }
}

impl ::protobuf::Clear for GoogleMessage {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoogleMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoogleMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FcmResult {
    // message fields
    successful: ::std::option::Option<bool>,
    status: ::std::option::Option<FcmResult_Status>,
    multicast_id: ::std::option::Option<i64>,
    canonical_ids: ::std::option::Option<u64>,
    message_id: ::protobuf::SingularField<::std::string::String>,
    registration_id: ::protobuf::SingularField<::std::string::String>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FcmResult {
    pub fn new() -> FcmResult {
        ::std::default::Default::default()
    }

    // required bool successful = 1;

    pub fn clear_successful(&mut self) {
        self.successful = ::std::option::Option::None;
    }

    pub fn has_successful(&self) -> bool {
        self.successful.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successful(&mut self, v: bool) {
        self.successful = ::std::option::Option::Some(v);
    }

    pub fn get_successful(&self) -> bool {
        self.successful.unwrap_or(false)
    }

    // optional .notification.FcmResult.Status status = 2;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: FcmResult_Status) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status(&self) -> FcmResult_Status {
        self.status.unwrap_or(FcmResult_Status::Success)
    }

    // optional int64 multicast_id = 3;

    pub fn clear_multicast_id(&mut self) {
        self.multicast_id = ::std::option::Option::None;
    }

    pub fn has_multicast_id(&self) -> bool {
        self.multicast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast_id(&mut self, v: i64) {
        self.multicast_id = ::std::option::Option::Some(v);
    }

    pub fn get_multicast_id(&self) -> i64 {
        self.multicast_id.unwrap_or(0)
    }

    // optional uint64 canonical_ids = 4;

    pub fn clear_canonical_ids(&mut self) {
        self.canonical_ids = ::std::option::Option::None;
    }

    pub fn has_canonical_ids(&self) -> bool {
        self.canonical_ids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonical_ids(&mut self, v: u64) {
        self.canonical_ids = ::std::option::Option::Some(v);
    }

    pub fn get_canonical_ids(&self) -> u64 {
        self.canonical_ids.unwrap_or(0)
    }

    // optional string message_id = 5;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        self.message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message_id(&self) -> &str {
        match self.message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string registration_id = 6;

    pub fn clear_registration_id(&mut self) {
        self.registration_id.clear();
    }

    pub fn has_registration_id(&self) -> bool {
        self.registration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registration_id(&mut self, v: ::std::string::String) {
        self.registration_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registration_id(&mut self) -> &mut ::std::string::String {
        if self.registration_id.is_none() {
            self.registration_id.set_default();
        }
        self.registration_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_registration_id(&mut self) -> ::std::string::String {
        self.registration_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_registration_id(&self) -> &str {
        match self.registration_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string error = 7;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FcmResult {
    fn is_initialized(&self) -> bool {
        if self.successful.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.successful = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.multicast_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.canonical_ids = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.registration_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.successful {
            my_size += 2;
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.multicast_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.canonical_ids {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.registration_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.successful {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.multicast_id {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.canonical_ids {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.registration_id.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FcmResult {
        FcmResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "successful",
                    |m: &FcmResult| { &m.successful },
                    |m: &mut FcmResult| { &mut m.successful },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FcmResult_Status>>(
                    "status",
                    |m: &FcmResult| { &m.status },
                    |m: &mut FcmResult| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "multicast_id",
                    |m: &FcmResult| { &m.multicast_id },
                    |m: &mut FcmResult| { &mut m.multicast_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "canonical_ids",
                    |m: &FcmResult| { &m.canonical_ids },
                    |m: &mut FcmResult| { &mut m.canonical_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &FcmResult| { &m.message_id },
                    |m: &mut FcmResult| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "registration_id",
                    |m: &FcmResult| { &m.registration_id },
                    |m: &mut FcmResult| { &mut m.registration_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &FcmResult| { &m.error },
                    |m: &mut FcmResult| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FcmResult>(
                    "FcmResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FcmResult {
        static mut instance: ::protobuf::lazy::Lazy<FcmResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FcmResult,
        };
        unsafe {
            instance.get(FcmResult::new)
        }
    }
}

impl ::protobuf::Clear for FcmResult {
    fn clear(&mut self) {
        self.clear_successful();
        self.clear_status();
        self.clear_multicast_id();
        self.clear_canonical_ids();
        self.clear_message_id();
        self.clear_registration_id();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FcmResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FcmResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FcmResult_Status {
    Success = 1,
    Unauthorized = 2,
    InvalidMessage = 3,
    ServerError = 4,
    MissingRegistration = 5,
    InvalidRegistration = 6,
    NotRegistered = 7,
    InvalidPackageName = 8,
    MismatchSenderId = 9,
    MessageTooBig = 10,
    InvalidDataKey = 11,
    InvalidTtl = 12,
    Unavailable = 13,
    DeviceMessageRateExceeded = 14,
    TopicsMessageRateExceeded = 15,
    MissingCertificate = 16,
    Unknown = 17,
}

impl ::protobuf::ProtobufEnum for FcmResult_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FcmResult_Status> {
        match value {
            1 => ::std::option::Option::Some(FcmResult_Status::Success),
            2 => ::std::option::Option::Some(FcmResult_Status::Unauthorized),
            3 => ::std::option::Option::Some(FcmResult_Status::InvalidMessage),
            4 => ::std::option::Option::Some(FcmResult_Status::ServerError),
            5 => ::std::option::Option::Some(FcmResult_Status::MissingRegistration),
            6 => ::std::option::Option::Some(FcmResult_Status::InvalidRegistration),
            7 => ::std::option::Option::Some(FcmResult_Status::NotRegistered),
            8 => ::std::option::Option::Some(FcmResult_Status::InvalidPackageName),
            9 => ::std::option::Option::Some(FcmResult_Status::MismatchSenderId),
            10 => ::std::option::Option::Some(FcmResult_Status::MessageTooBig),
            11 => ::std::option::Option::Some(FcmResult_Status::InvalidDataKey),
            12 => ::std::option::Option::Some(FcmResult_Status::InvalidTtl),
            13 => ::std::option::Option::Some(FcmResult_Status::Unavailable),
            14 => ::std::option::Option::Some(FcmResult_Status::DeviceMessageRateExceeded),
            15 => ::std::option::Option::Some(FcmResult_Status::TopicsMessageRateExceeded),
            16 => ::std::option::Option::Some(FcmResult_Status::MissingCertificate),
            17 => ::std::option::Option::Some(FcmResult_Status::Unknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FcmResult_Status] = &[
            FcmResult_Status::Success,
            FcmResult_Status::Unauthorized,
            FcmResult_Status::InvalidMessage,
            FcmResult_Status::ServerError,
            FcmResult_Status::MissingRegistration,
            FcmResult_Status::InvalidRegistration,
            FcmResult_Status::NotRegistered,
            FcmResult_Status::InvalidPackageName,
            FcmResult_Status::MismatchSenderId,
            FcmResult_Status::MessageTooBig,
            FcmResult_Status::InvalidDataKey,
            FcmResult_Status::InvalidTtl,
            FcmResult_Status::Unavailable,
            FcmResult_Status::DeviceMessageRateExceeded,
            FcmResult_Status::TopicsMessageRateExceeded,
            FcmResult_Status::MissingCertificate,
            FcmResult_Status::Unknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FcmResult_Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FcmResult_Status {
}

impl ::protobuf::reflect::ProtobufValue for FcmResult_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoogleNotification {
    // message fields
    response: ::protobuf::SingularPtrField<FcmResult>,
    registration_ids: ::protobuf::RepeatedField<::std::string::String>,
    collapse_key: ::protobuf::SingularField<::std::string::String>,
    priority: ::std::option::Option<GoogleNotification_Priority>,
    content_available: ::std::option::Option<bool>,
    delay_while_idle: ::std::option::Option<bool>,
    time_to_live: ::std::option::Option<i32>,
    restricted_package_name: ::protobuf::SingularField<::std::string::String>,
    dry_run: ::std::option::Option<bool>,
    // message oneof groups
    pub field_type: ::std::option::Option<GoogleNotification_oneof_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum GoogleNotification_oneof_type {
    message(GoogleMessage),
    localized(GoogleLocalizedAlert),
}

impl GoogleNotification {
    pub fn new() -> GoogleNotification {
        ::std::default::Default::default()
    }

    // optional .notification.FcmResult response = 1;

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: FcmResult) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut FcmResult {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> FcmResult {
        self.response.take().unwrap_or_else(|| FcmResult::new())
    }

    pub fn get_response(&self) -> &FcmResult {
        self.response.as_ref().unwrap_or_else(|| FcmResult::default_instance())
    }

    // repeated string registration_ids = 2;

    pub fn clear_registration_ids(&mut self) {
        self.registration_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_registration_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.registration_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_registration_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.registration_ids
    }

    // Take field
    pub fn take_registration_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.registration_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_registration_ids(&self) -> &[::std::string::String] {
        &self.registration_ids
    }

    // optional string collapse_key = 3;

    pub fn clear_collapse_key(&mut self) {
        self.collapse_key.clear();
    }

    pub fn has_collapse_key(&self) -> bool {
        self.collapse_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collapse_key(&mut self, v: ::std::string::String) {
        self.collapse_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collapse_key(&mut self) -> &mut ::std::string::String {
        if self.collapse_key.is_none() {
            self.collapse_key.set_default();
        }
        self.collapse_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_collapse_key(&mut self) -> ::std::string::String {
        self.collapse_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_collapse_key(&self) -> &str {
        match self.collapse_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .notification.GoogleNotification.Priority priority = 4;

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: GoogleNotification_Priority) {
        self.priority = ::std::option::Option::Some(v);
    }

    pub fn get_priority(&self) -> GoogleNotification_Priority {
        self.priority.unwrap_or(GoogleNotification_Priority::Normal)
    }

    // optional bool content_available = 5;

    pub fn clear_content_available(&mut self) {
        self.content_available = ::std::option::Option::None;
    }

    pub fn has_content_available(&self) -> bool {
        self.content_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_available(&mut self, v: bool) {
        self.content_available = ::std::option::Option::Some(v);
    }

    pub fn get_content_available(&self) -> bool {
        self.content_available.unwrap_or(false)
    }

    // optional bool delay_while_idle = 6;

    pub fn clear_delay_while_idle(&mut self) {
        self.delay_while_idle = ::std::option::Option::None;
    }

    pub fn has_delay_while_idle(&self) -> bool {
        self.delay_while_idle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_while_idle(&mut self, v: bool) {
        self.delay_while_idle = ::std::option::Option::Some(v);
    }

    pub fn get_delay_while_idle(&self) -> bool {
        self.delay_while_idle.unwrap_or(false)
    }

    // optional int32 time_to_live = 7;

    pub fn clear_time_to_live(&mut self) {
        self.time_to_live = ::std::option::Option::None;
    }

    pub fn has_time_to_live(&self) -> bool {
        self.time_to_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_live(&mut self, v: i32) {
        self.time_to_live = ::std::option::Option::Some(v);
    }

    pub fn get_time_to_live(&self) -> i32 {
        self.time_to_live.unwrap_or(0)
    }

    // optional string restricted_package_name = 8;

    pub fn clear_restricted_package_name(&mut self) {
        self.restricted_package_name.clear();
    }

    pub fn has_restricted_package_name(&self) -> bool {
        self.restricted_package_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted_package_name(&mut self, v: ::std::string::String) {
        self.restricted_package_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restricted_package_name(&mut self) -> &mut ::std::string::String {
        if self.restricted_package_name.is_none() {
            self.restricted_package_name.set_default();
        }
        self.restricted_package_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_restricted_package_name(&mut self) -> ::std::string::String {
        self.restricted_package_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_restricted_package_name(&self) -> &str {
        match self.restricted_package_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool dry_run = 9;

    pub fn clear_dry_run(&mut self) {
        self.dry_run = ::std::option::Option::None;
    }

    pub fn has_dry_run(&self) -> bool {
        self.dry_run.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dry_run(&mut self, v: bool) {
        self.dry_run = ::std::option::Option::Some(v);
    }

    pub fn get_dry_run(&self) -> bool {
        self.dry_run.unwrap_or(false)
    }

    // optional .notification.GoogleMessage message = 10;

    pub fn clear_message(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: GoogleMessage) {
        self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message(&mut self) -> &mut GoogleMessage {
        if let ::std::option::Option::Some(GoogleNotification_oneof_type::message(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::message(GoogleMessage::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message(&mut self) -> GoogleMessage {
        if self.has_message() {
            match self.field_type.take() {
                ::std::option::Option::Some(GoogleNotification_oneof_type::message(v)) => v,
                _ => panic!(),
            }
        } else {
            GoogleMessage::new()
        }
    }

    pub fn get_message(&self) -> &GoogleMessage {
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::message(ref v)) => v,
            _ => GoogleMessage::default_instance(),
        }
    }

    // optional .notification.GoogleLocalizedAlert localized = 11;

    pub fn clear_localized(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_localized(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::localized(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_localized(&mut self, v: GoogleLocalizedAlert) {
        self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::localized(v))
    }

    // Mutable pointer to the field.
    pub fn mut_localized(&mut self) -> &mut GoogleLocalizedAlert {
        if let ::std::option::Option::Some(GoogleNotification_oneof_type::localized(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::localized(GoogleLocalizedAlert::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::localized(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_localized(&mut self) -> GoogleLocalizedAlert {
        if self.has_localized() {
            match self.field_type.take() {
                ::std::option::Option::Some(GoogleNotification_oneof_type::localized(v)) => v,
                _ => panic!(),
            }
        } else {
            GoogleLocalizedAlert::new()
        }
    }

    pub fn get_localized(&self) -> &GoogleLocalizedAlert {
        match self.field_type {
            ::std::option::Option::Some(GoogleNotification_oneof_type::localized(ref v)) => v,
            _ => GoogleLocalizedAlert::default_instance(),
        }
    }
}

impl ::protobuf::Message for GoogleNotification {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(GoogleNotification_oneof_type::message(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GoogleNotification_oneof_type::localized(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.registration_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.collapse_key)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.priority, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.content_available = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delay_while_idle = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time_to_live = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.restricted_package_name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dry_run = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::message(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(GoogleNotification_oneof_type::localized(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.registration_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.collapse_key.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.content_available {
            my_size += 2;
        }
        if let Some(v) = self.delay_while_idle {
            my_size += 2;
        }
        if let Some(v) = self.time_to_live {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.restricted_package_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.dry_run {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &GoogleNotification_oneof_type::message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GoogleNotification_oneof_type::localized(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.registration_ids {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.collapse_key.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.priority {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.content_available {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.delay_while_idle {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.time_to_live {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.restricted_package_name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.dry_run {
            os.write_bool(9, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &GoogleNotification_oneof_type::message(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GoogleNotification_oneof_type::localized(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoogleNotification {
        GoogleNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FcmResult>>(
                    "response",
                    |m: &GoogleNotification| { &m.response },
                    |m: &mut GoogleNotification| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "registration_ids",
                    |m: &GoogleNotification| { &m.registration_ids },
                    |m: &mut GoogleNotification| { &mut m.registration_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collapse_key",
                    |m: &GoogleNotification| { &m.collapse_key },
                    |m: &mut GoogleNotification| { &mut m.collapse_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoogleNotification_Priority>>(
                    "priority",
                    |m: &GoogleNotification| { &m.priority },
                    |m: &mut GoogleNotification| { &mut m.priority },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "content_available",
                    |m: &GoogleNotification| { &m.content_available },
                    |m: &mut GoogleNotification| { &mut m.content_available },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delay_while_idle",
                    |m: &GoogleNotification| { &m.delay_while_idle },
                    |m: &mut GoogleNotification| { &mut m.delay_while_idle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "time_to_live",
                    |m: &GoogleNotification| { &m.time_to_live },
                    |m: &mut GoogleNotification| { &mut m.time_to_live },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "restricted_package_name",
                    |m: &GoogleNotification| { &m.restricted_package_name },
                    |m: &mut GoogleNotification| { &mut m.restricted_package_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dry_run",
                    |m: &GoogleNotification| { &m.dry_run },
                    |m: &mut GoogleNotification| { &mut m.dry_run },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GoogleMessage>(
                    "message",
                    GoogleNotification::has_message,
                    GoogleNotification::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GoogleLocalizedAlert>(
                    "localized",
                    GoogleNotification::has_localized,
                    GoogleNotification::get_localized,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoogleNotification>(
                    "GoogleNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoogleNotification {
        static mut instance: ::protobuf::lazy::Lazy<GoogleNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoogleNotification,
        };
        unsafe {
            instance.get(GoogleNotification::new)
        }
    }
}

impl ::protobuf::Clear for GoogleNotification {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_registration_ids();
        self.clear_collapse_key();
        self.clear_priority();
        self.clear_content_available();
        self.clear_delay_while_idle();
        self.clear_time_to_live();
        self.clear_restricted_package_name();
        self.clear_dry_run();
        self.clear_message();
        self.clear_localized();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoogleNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoogleNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoogleNotification_Priority {
    Normal = 1,
    High = 2,
}

impl ::protobuf::ProtobufEnum for GoogleNotification_Priority {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoogleNotification_Priority> {
        match value {
            1 => ::std::option::Option::Some(GoogleNotification_Priority::Normal),
            2 => ::std::option::Option::Some(GoogleNotification_Priority::High),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoogleNotification_Priority] = &[
            GoogleNotification_Priority::Normal,
            GoogleNotification_Priority::High,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoogleNotification_Priority", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoogleNotification_Priority {
}

impl ::protobuf::reflect::ProtobufValue for GoogleNotification_Priority {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&notification/google_notification.proto\x12\x0cnotification\x1a\x1ccom\
    mon/map_field_entry.proto\"\x92\x02\n\x14GoogleLocalizedAlert\x12\r\n\
    \x05title\x18\x01\x20\x01(\t\x12\x0c\n\x04body\x18\x02\x20\x01(\t\x12\
    \x0c\n\x04icon\x18\x03\x20\x01(\t\x12\r\n\x05sound\x18\x04\x20\x01(\t\
    \x12\r\n\x05badge\x18\x05\x20\x01(\t\x12\x0b\n\x03tag\x18\x06\x20\x01(\t\
    \x12\r\n\x05color\x18\x07\x20\x01(\t\x12\x14\n\x0cclick_action\x18\x08\
    \x20\x01(\t\x12\x14\n\x0cbody_loc_key\x18\t\x20\x01(\t\x12\x15\n\rbody_l\
    oc_args\x18\n\x20\x03(\t\x12\x15\n\rtitle_loc_key\x18\x0b\x20\x01(\t\x12\
    \x16\n\x0etitle_loc_args\x18\x0c\x20\x03(\t\x12#\n\x04data\x18\r\x20\x03\
    (\x0b2\x15.common.MapFieldEntry\"4\n\rGoogleMessage\x12#\n\x04data\x18\
    \x01\x20\x03(\x0b2\x15.common.MapFieldEntry\"\xa5\x04\n\tFcmResult\x12\
    \x12\n\nsuccessful\x18\x01\x20\x02(\x08\x12.\n\x06status\x18\x02\x20\x01\
    (\x0e2\x1e.notification.FcmResult.Status\x12\x14\n\x0cmulticast_id\x18\
    \x03\x20\x01(\x03\x12\x15\n\rcanonical_ids\x18\x04\x20\x01(\x04\x12\x12\
    \n\nmessage_id\x18\x05\x20\x01(\t\x12\x17\n\x0fregistration_id\x18\x06\
    \x20\x01(\t\x12\r\n\x05error\x18\x07\x20\x01(\t\"\xea\x02\n\x06Status\
    \x12\x0b\n\x07Success\x10\x01\x12\x10\n\x0cUnauthorized\x10\x02\x12\x12\
    \n\x0eInvalidMessage\x10\x03\x12\x0f\n\x0bServerError\x10\x04\x12\x17\n\
    \x13MissingRegistration\x10\x05\x12\x17\n\x13InvalidRegistration\x10\x06\
    \x12\x11\n\rNotRegistered\x10\x07\x12\x16\n\x12InvalidPackageName\x10\
    \x08\x12\x14\n\x10MismatchSenderId\x10\t\x12\x11\n\rMessageTooBig\x10\n\
    \x12\x12\n\x0eInvalidDataKey\x10\x0b\x12\x0e\n\nInvalidTtl\x10\x0c\x12\
    \x0f\n\x0bUnavailable\x10\r\x12\x1d\n\x19DeviceMessageRateExceeded\x10\
    \x0e\x12\x1d\n\x19TopicsMessageRateExceeded\x10\x0f\x12\x16\n\x12Missing\
    Certificate\x10\x10\x12\x0b\n\x07Unknown\x10\x11\"\xbc\x03\n\x12GoogleNo\
    tification\x12)\n\x08response\x18\x01\x20\x01(\x0b2\x17.notification.Fcm\
    Result\x12\x18\n\x10registration_ids\x18\x02\x20\x03(\t\x12\x14\n\x0ccol\
    lapse_key\x18\x03\x20\x01(\t\x12;\n\x08priority\x18\x04\x20\x01(\x0e2).n\
    otification.GoogleNotification.Priority\x12\x19\n\x11content_available\
    \x18\x05\x20\x01(\x08\x12\x18\n\x10delay_while_idle\x18\x06\x20\x01(\x08\
    \x12\x14\n\x0ctime_to_live\x18\x07\x20\x01(\x05\x12\x1f\n\x17restricted_\
    package_name\x18\x08\x20\x01(\t\x12\x0f\n\x07dry_run\x18\t\x20\x01(\x08\
    \x12.\n\x07message\x18\n\x20\x01(\x0b2\x1b.notification.GoogleMessageH\0\
    \x127\n\tlocalized\x18\x0b\x20\x01(\x0b2\".notification.GoogleLocalizedA\
    lertH\0\"\x20\n\x08Priority\x12\n\n\x06Normal\x10\x01\x12\x08\n\x04High\
    \x10\x02B\x06\n\x04type\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
